@page "/bins"
@using EcoRoute.DtoLayer.WasteBinDtos
@using EcoRoute.UI.Pages.Components.WasteBins
@using EcoRoute.UI.Services.WasteBinServices
@using Microsoft.AspNetCore.Authorization
@using Microsoft.JSInterop
@inject WasteBinService WasteBinService
@inject SensorService SensorService
@inject IToastService toastService
@inject IJSRuntime JS
@attribute [Authorize(Roles = "SuperAdmin, Manager")]

<!-- Main Kısmı -->
<div class="bg-white dark:bg-gray-900 shadow-md rounded-lg overflow-hidden mb-6">
    <div class="flex justify-between items-center p-6 border-b border-gray-200 dark:border-gray-700">
        <h2 class="text-2xl font-semibold text-gray-800 dark:text-white">Atık Kutusu Yönetimi</h2>
        <div class="flex space-x-2">
            <button class="flex items-center bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed"
                    @onclick="RefreshData"
                    disabled="@isRefreshing">
                @if (isRefreshing)
                {
                    <i class="fas fa-circle-notch fa-spin mr-2"></i>
                }
                else
                {
                    <i class="fas fa-sync-alt mr-2"></i>
                }
                Yenile
            </button>
            <button class="flex items-center bg-primary-500 text-white px-4 py-2 rounded-md hover:bg-primary-600 transition duration-300" @onclick="OpenCreateModal">
                <i class="fas fa-plus mr-2"></i> Yeni Atık Kutusu Ekle
            </button>
        </div>
    </div>

    <!-- Harita Bölümü -->
    <BinMapSection OnBinDetail="OpenBinDetail"
                   OnEditBin="EditBin"
                   OnBinSidebar="OpenBinSidebar" />

    <!-- Filtre Bölümü -->
    <BinFilterSection SearchText="@searchText"
                      StatusFilter="@statusFilter"
                      FillLevelFilter="@fillLevelFilter"
                      OnSearchChanged="@((searchValue) => OnSearchChanged(searchValue))"
                      OnStatusFilterChanged="@((e) => FilterByStatus(e))"
                      OnFillLevelFilterChanged="@((e) => FilterByFillLevel(e))"
                      OnClearFilters="@(() => ClearFilters())" />

    <!-- Tablo Bölümü -->
    <BinTable WasteBins="@filteredBins"
              DisplayedBins="@displayedBins"
              ExpandedRowId="@expandedRowId"
              SortField="@sortField"
              SortAscending="@sortAscending"
              CurrentPage="@currentPage"
              PageSize="@pageSize"
              TotalPages="@totalPages"
              StartPage="@startPage"
              EndPage="@endPage"
              IsDeleting="@isDeleting"
              LoadingSensorIds="@loadingSensorIds"
              OnSort="@((field) => SortTable(field))"
              OnRowExpand="@((id) => ToggleRowExpansion(id))"
              OnEdit="@((bin) => OpenEditModal(bin))"
              OnDelete="@((id) => DeleteBinConfirmation(id))"
              OnFocusOnBin="@(async (id) => await FocusOnBin(id))"
              OnPageChange="@((page) => ChangePage(page))"
              OnToggleSensorStatus="@(async (tuple) => await ToggleSensorStatus(tuple.Item1, tuple.Item2, tuple.Item3))"
              OnToggleSensorWorking="@(async (tuple) => await ToggleSensorWorking(tuple.Item1, tuple.Item2, tuple.Item3))" />
</div>

<!-- Sidebar for bin details -->
<div id="bin-sidebar" class="fixed top-0 right-[-400px] h-full w-[400px] bg-white dark:bg-gray-800 shadow-lg z-50 overflow-y-auto transition-all duration-300 ease-in-out border-l-4 border-primary-500">
    <!-- Sidebar content will be dynamically populated by JavaScript -->
</div>

<!-- Modals -->
<BinDeleteConfirmModal ShowModal="@showDeleteConfirmation"
                       IsDeleting="@isDeleting"
                       OnCancel="@(() => CancelDelete())"
                       OnConfirm="@(async () => await ConfirmDelete())" />

<BinSaveConfirmModal ShowModal="@showSaveConfirmation"
                     IsEdit="@showEditModal"
                     IsSaving="@isSaving"
                     OnCancel="@(() => showSaveConfirmation = false)"
                     OnConfirm="@(async () => await SaveBin())" />

<BinLocationPicker ShowModal="@showLocationPickerModal"
                   BinModel="@binModel"
                   WasteBins="@wasteBins"
                   EditingId="@editingId"
                   IsEdit="@showEditModal"
                   OnClose="@(() => CloseLocationPickerModal())"
                   OnConfirm="@(() => ConfirmLocationSelection())"
                   OnCoordinatesUpdate="UpdateCoordinatesFromEvent"
                   OnAddressUpdate="UpdateAddress" />

<BinFormModal ShowCreateModal="@showCreateModal"
              ShowEditModal="@showEditModal"
              BinModel="@binModel"
              IsSaving="@isSaving"
              OnClose="@(async () => await CloseModal())"
              OnSave="@(() => ShowSaveConfirmation())"
              OnLocationPicker="@(async () => await OpenLocationPicker())"
              OnFillLevelChange="OnFillLevelInput"
              OnSensorCountChange="OnSensorCountChange" />

@code {
    private List<ResultWasteBinDto> wasteBins;
    private List<ResultWasteBinDto> filteredBins = new List<ResultWasteBinDto>();
    private List<ResultWasteBinDto> displayedBins => GetDisplayedBins();
    private CreateWasteBinDto binModel = new();
    private ResultWasteBinDto selectedBin;

    private Guid editingId;
    private Guid expandedRowId;
    private Guid binIdToDelete;
    private string searchText = "";
    private string statusFilter = "";
    private string fillLevelFilter = "";

    // UI state
    private bool showCreateModal = false;
    private bool showEditModal = false;
    private bool showLocationPickerModal = false;
    private bool showDeleteConfirmation = false;
    private bool showSaveConfirmation = false;

    // Loading states
    private bool isRefreshing = false;
    private bool isSaving = false;
    private bool isDeleting = false;
    private HashSet<Guid> loadingSensorIds = new HashSet<Guid>();

    // Pagination
    private int currentPage = 1;
    private int pageSize = 10;
    private int totalPages => filteredBins == null ? 0 : (int)Math.Ceiling(filteredBins.Count / (double)pageSize);
    private int startPage => Math.Max(1, currentPage - 2);
    private int endPage => Math.Min(totalPages, startPage + 4);

    // Sorting
    private string sortField = "Index";
    private bool sortAscending = true;

    // Map flags
    private bool mainMapInitialized = false;
    private Guid _lastExpandedRowId = Guid.Empty;

    protected override async Task OnInitializedAsync()
    {
        await LoadData();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        try
        {
            if (firstRender)
            {
                await JS.InvokeVoidAsync("initializeGoogleMaps", DotNetObjectReference.Create(this));
                await Task.Delay(500);
                await InitializeMainMap();
            }

            if (expandedRowId != Guid.Empty && expandedRowId != _lastExpandedRowId)
            {
                _lastExpandedRowId = expandedRowId;
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error in OnAfterRenderAsync: {ex.Message}");
            toastService.ShowError($"Render hatası: {ex.Message}");
        }
    }

    private async Task InitializeMainMap()
    {
        try
        {
            await JS.InvokeVoidAsync("googleMapsInterop.initializeMainMap", "main-map");
            await ShowAllBinsOnMap();
            mainMapInitialized = true;
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error initializing main map: {ex.Message}");
            toastService.ShowError($"Harita yüklenemedi: {ex.Message}");
        }
    }

    private List<ResultWasteBinDto> GetDisplayedBins()
    {
        if (filteredBins == null) return new List<ResultWasteBinDto>();

        return filteredBins
            .Skip((currentPage - 1) * pageSize)
            .Take(pageSize)
            .ToList();
    }

    private async Task LoadData()
    {
        wasteBins = await WasteBinService.GetAllWasteBinsAsync();
        ApplyFilters();
    }

    private void ApplyFilters()
    {
        if (wasteBins == null)
        {
            filteredBins = new List<ResultWasteBinDto>();
            return;
        }

        var query = wasteBins.AsEnumerable();

        if (!string.IsNullOrEmpty(statusFilter))
        {
            query = query.Where(b => b.DeviceStatus == statusFilter);
        }

        if (!string.IsNullOrEmpty(fillLevelFilter))
        {
            var parts = fillLevelFilter.Split('-');
            if (parts.Length == 2 &&
                double.TryParse(parts[0], out double min) &&
                double.TryParse(parts[1], out double max))
            {
                query = query.Where(b => b.FillLevel >= min && b.FillLevel <= max);
            }
        }

        if (!string.IsNullOrEmpty(searchText))
        {
            var search = searchText.ToLower();
            query = query.Where(b =>
                (b.Label?.ToLower().Contains(search) == true) ||
                (b.Address?.ToLower().Contains(search) == true));
        }

        query = ApplySorting(query);
        filteredBins = query.ToList();

        if (currentPage > 1 && (currentPage - 1) * pageSize >= filteredBins.Count)
        {
            currentPage = 1;
        }
    }

    private IEnumerable<ResultWasteBinDto> ApplySorting(IEnumerable<ResultWasteBinDto> query)
    {
        switch (sortField)
        {
            case "Index":
                return sortAscending
                    ? query.Select((item, index) => new { Item = item, Index = index })
                            .OrderBy(x => x.Index)
                            .Select(x => x.Item)
                    : query.Select((item, index) => new { Item = item, Index = index })
                            .OrderByDescending(x => x.Index)
                            .Select(x => x.Item);
            case "Label":
                return sortAscending ? query.OrderBy(b => b.Label) : query.OrderByDescending(b => b.Label);
            case "Address":
                return sortAscending ? query.OrderBy(b => b.Address) : query.OrderByDescending(b => b.Address);
            case "LastUpdate":
                return sortAscending ? query.OrderBy(b => b.UpdatedAt) : query.OrderByDescending(b => b.UpdatedAt);
            case "DeviceStatus":
                return sortAscending ? query.OrderBy(b => b.DeviceStatus) : query.OrderByDescending(b => b.DeviceStatus);
            case "FillLevel":
                return sortAscending ? query.OrderBy(b => b.FillLevel ?? 0) : query.OrderByDescending(b => b.FillLevel ?? 0);
            default:
                return query;
        }
    }

    private async Task RefreshData()
    {
        if (isRefreshing) return;

        try
        {
            isRefreshing = true;
            expandedRowId = Guid.Empty;
            await LoadData();
            await ShowAllBinsOnMap();
            toastService.ShowSuccess("Veriler yenilendi");
        }
        catch (Exception ex)
        {
            toastService.ShowError($"Veri yenileme sırasında hata oluştu: {ex.Message}");
        }
        finally
        {
            isRefreshing = false;
            StateHasChanged();
        }
    }

    #region Sensor Management

    private async Task ToggleSensorStatus(Guid sensorId, bool currentIsActive, bool currentIsWorking)
    {
        if (loadingSensorIds.Contains(sensorId)) return;

        try
        {
            loadingSensorIds.Add(sensorId);
            StateHasChanged();

            var success = await SensorService.UpdateSensorStatusAsync(sensorId, !currentIsActive, currentIsWorking);
            if (success)
            {
                toastService.ShowSuccess("Sensör durumu güncellendi.");
                await LoadData();
            }
            else
            {
                toastService.ShowError("Sensör durum güncelleme işlemi başarısız.");
            }
        }
        catch (Exception ex)
        {
            toastService.ShowError($"Sensör durum güncelleme sırasında hata oluştu: {ex.Message}");
        }
        finally
        {
            loadingSensorIds.Remove(sensorId);
            StateHasChanged();
        }
    }

    private async Task ToggleSensorWorking(Guid sensorId, bool currentIsActive, bool currentIsWorking)
    {
        if (loadingSensorIds.Contains(sensorId)) return;

        try
        {
            loadingSensorIds.Add(sensorId);
            StateHasChanged();

            var success = await SensorService.UpdateSensorStatusAsync(sensorId, currentIsActive, !currentIsWorking);
            if (success)
            {
                toastService.ShowSuccess("Sensör çalışma durumu güncellendi.");
                await LoadData();
            }
            else
            {
                toastService.ShowError("Sensör çalışma durumu güncelleme işlemi başarısız.");
            }
        }
        catch (Exception ex)
        {
            toastService.ShowError($"Sensör çalışma durumu güncelleme sırasında hata oluştu: {ex.Message}");
        }
        finally
        {
            loadingSensorIds.Remove(sensorId);
            StateHasChanged();
        }
    }

    #endregion

    // Rest of the existing methods remain the same...
    private void FilterByStatus(ChangeEventArgs e)
    {
        statusFilter = e.Value?.ToString() ?? "";
        ApplyFilters();
    }

    private void FilterByFillLevel(ChangeEventArgs e)
    {
        fillLevelFilter = e.Value?.ToString() ?? "";
        ApplyFilters();
    }

    private void OnSearchChanged(string searchValue)
    {
        searchText = searchValue;
        ApplyFilters();
    }

    private async Task ClearFilters()
    {
        searchText = "";
        statusFilter = "";
        fillLevelFilter = "";
        await JS.InvokeVoidAsync("resetFilterDropdowns");
        ApplyFilters();
        StateHasChanged();
    }

    private void SortTable(string field)
    {
        expandedRowId = Guid.Empty;

        if (sortField == field)
        {
            sortAscending = !sortAscending;
        }
        else
        {
            sortField = field;
            sortAscending = true;
        }

        ApplyFilters();
    }

    private void ChangePage(int page)
    {
        currentPage = page;
        expandedRowId = Guid.Empty;
    }

    private void ToggleRowExpansion(Guid id)
    {
        if (expandedRowId == id)
        {
            expandedRowId = Guid.Empty;
        }
        else
        {
            expandedRowId = id;
        }
        _lastExpandedRowId = Guid.Empty;
    }

    private void OnFillLevelInput(ChangeEventArgs args)
    {
        if (double.TryParse(args.Value.ToString(), out double value))
        {
            binModel.FillLevel = value;
            binModel.IsFilled = value >= 90;
        }
    }

    private void OnSensorCountChange(ChangeEventArgs args)
    {
        if (int.TryParse(args.Value.ToString(), out int value))
        {
            binModel.SensorCount = Math.Max(0, Math.Min(20, value));
        }
    }

    private async Task OpenCreateModal()
    {
        try
        {
            await JS.InvokeVoidAsync("googleMapsInterop.resetMapState");
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error resetting map: {ex.Message}");
        }

        binModel = new CreateWasteBinDto
            {
                DeviceStatus = "Active",
                Latitude = 41.1634,
                Longitude = 27.7951,
                FillLevel = 0,
                IsFilled = false,
                SensorCount = 1
            };

        showCreateModal = true;
        showEditModal = false;
    }

    private void OpenEditModal(ResultWasteBinDto bin)
    {
        try
        {
            JS.InvokeVoidAsync("googleMapsInterop.resetMapState");
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error resetting map state before opening edit modal: {ex.Message}");
        }

        binModel = new CreateWasteBinDto
            {
                Label = bin.Label,
                Address = bin.Address,
                Latitude = bin.Latitude,
                Longitude = bin.Longitude,
                IsFilled = bin.IsFilled,
                FillLevel = bin.FillLevel,
                DeviceStatus = bin.DeviceStatus,
                SensorCount = bin.SensorCount,
                CreatedAt = bin.CreatedAt,
                UpdatedAt = DateTime.Now
            };

        editingId = bin.Id;
        showEditModal = true;
        showCreateModal = false;
    }

    private async Task OpenLocationPicker()
    {
        showLocationPickerModal = true;
        StateHasChanged();
        await Task.Delay(100);
    }

    private void CloseLocationPickerModal()
    {
        showLocationPickerModal = false;
    }

    private void ConfirmLocationSelection()
    {
        showLocationPickerModal = false;
    }

    private async Task CloseModal()
    {
        showCreateModal = false;
        showEditModal = false;

        try
        {
            await JS.InvokeVoidAsync("googleMapsInterop.resetMapState");
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Error resetting map: {ex.Message}");
        }

        binModel = new();
    }

    private void DeleteBinConfirmation(Guid id)
    {
        if (isDeleting) return;

        binIdToDelete = id;
        showDeleteConfirmation = true;
    }

    private void CancelDelete()
    {
        if (isDeleting) return;

        showDeleteConfirmation = false;
        binIdToDelete = Guid.Empty;
    }

    private async Task ConfirmDelete()
    {
        if (isDeleting) return;

        try
        {
            isDeleting = true;
            StateHasChanged();

            var success = await WasteBinService.DeleteWasteBinAsync(binIdToDelete);
            if (success)
            {
                toastService.ShowSuccess("Atık kutusu ve sensörleri başarıyla silindi.");
                await LoadData();
                await ShowAllBinsOnMap();

                if (expandedRowId == binIdToDelete)
                {
                    expandedRowId = Guid.Empty;
                }
            }
            else
            {
                toastService.ShowError("Silme işlemi sırasında bir hata oluştu.");
            }
        }
        catch (Exception ex)
        {
            toastService.ShowError($"Silme işlemi sırasında hata oluştu: {ex.Message}");
        }
        finally
        {
            isDeleting = false;
            showDeleteConfirmation = false;
            StateHasChanged();
        }
    }

    private void ShowSaveConfirmation()
    {
        if (isSaving) return;

        if (string.IsNullOrWhiteSpace(binModel.Label) || string.IsNullOrWhiteSpace(binModel.Address) ||
            binModel.Latitude == 0 || binModel.Longitude == 0)
        {
            toastService.ShowWarning("Lütfen tüm zorunlu alanları doldurun.");
            return;
        }

        if (binModel.SensorCount < 0 || binModel.SensorCount > 20)
        {
            toastService.ShowWarning("Sensör adedi 0-20 arasında olmalıdır.");
            return;
        }

        showSaveConfirmation = true;
    }

    private async Task SaveBin()
    {
        if (isSaving) return;

        try
        {
            isSaving = true;
            StateHasChanged();

            bool success;

            if (showEditModal)
            {
                var updateDto = new UpdateWasteBinDto
                    {
                        WasteBinId = editingId,
                        Label = binModel.Label,
                        Address = binModel.Address,
                        Latitude = binModel.Latitude,
                        Longitude = binModel.Longitude,
                        IsFilled = binModel.IsFilled,
                        DeviceStatus = binModel.DeviceStatus,
                        FillLevel = binModel.FillLevel,
                        SensorCount = binModel.SensorCount,
                        UpdatedAt = DateTime.Now
                    };
                success = await WasteBinService.UpdateWasteBinAsync(updateDto);
            }
            else
            {
                binModel.CreatedAt = DateTime.Now;
                binModel.UpdatedAt = DateTime.Now;
                success = await WasteBinService.CreateWasteBinAsync(binModel);
            }

            if (success)
            {
                toastService.ShowSuccess(showEditModal ? "Atık kutusu başarıyla güncellendi." : "Atık kutusu ve sensörleri başarıyla eklendi.");
                showSaveConfirmation = false;

                try
                {
                    await JS.InvokeVoidAsync("googleMapsInterop.resetMapState");
                    await Task.Delay(100);
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine($"Error resetting map state after save: {ex.Message}");
                }

                showCreateModal = false;
                showEditModal = false;
                binModel = new();

                await LoadData();
                await ShowAllBinsOnMap();
            }
            else
            {
                toastService.ShowError("İşlem sırasında bir hata oluştu.");
                showSaveConfirmation = false;
            }
        }
        catch (Exception ex)
        {
            toastService.ShowError($"Kaydetme işlemi sırasında hata oluştu: {ex.Message}");
            showSaveConfirmation = false;
        }
        finally
        {
            isSaving = false;
            StateHasChanged();
        }
    }

    private async Task ShowAllBinsOnMap()
    {
        try
        {
            if (wasteBins == null || !wasteBins.Any())
            {
                wasteBins = await WasteBinService.GetAllWasteBinsAsync();
            }

            if (wasteBins != null && wasteBins.Any())
            {
                var binsJson = System.Text.Json.JsonSerializer.Serialize(wasteBins);
                await JS.InvokeVoidAsync("googleMapsInterop.showAllBins", binsJson);
            }
            else
            {
                toastService.ShowWarning("Gösterilecek atık kutusu bulunamadı");
            }
        }
        catch (Exception ex)
        {
            toastService.ShowError($"Atık kutuları haritada gösterilirken hata oluştu: {ex.Message}");
            Console.Error.WriteLine($"Error showing bins on map: {ex}");
        }
    }

    private async Task FocusOnBin(Guid binId)
    {
        await JS.InvokeVoidAsync("googleMapsInterop.focusOnBin", binId.ToString());
    }

    // JS Interop Methods
    [JSInvokable]
    public async Task OpenBinSidebar(string binId)
    {
        if (Guid.TryParse(binId, out Guid Id))
        {
            var bin = wasteBins?.FirstOrDefault(b => b.Id == Id);
            if (bin != null)
            {
                var binJson = System.Text.Json.JsonSerializer.Serialize(bin);
                await JS.InvokeVoidAsync("googleMapsInterop.showBinSidebar", bin);
                expandedRowId = Id;
                StateHasChanged();
            }
        }
    }

    [JSInvokable]
    public void EditBin(string binId)
    {
        if (Guid.TryParse(binId, out Guid Id))
        {
            var bin = wasteBins?.FirstOrDefault(b => b.Id == Id);
            if (bin != null)
            {
                OpenEditModal(bin);
            }
        }
    }

    [JSInvokable]
    public void OnMapInitialized()
    {
        Console.WriteLine("Map initialized from JS");
    }

    [JSInvokable]
    public void UpdateCoordinates(double lat, double lng)
    {
        binModel.Latitude = lat;
        binModel.Longitude = lng;
        StateHasChanged();
    }

    private void UpdateCoordinatesFromEvent(Tuple<double, double> coordinates)
    {
        UpdateCoordinates(coordinates.Item1, coordinates.Item2);
    }

    [JSInvokable]
    public void UpdateAddress(string address)
    {
        binModel.Address = address;
        StateHasChanged();
    }

    [JSInvokable]
    public async Task OpenBinDetail(string binId)
    {
        if (Guid.TryParse(binId, out Guid Id))
        {
            var binInCurrentPage = displayedBins.FirstOrDefault(b => b.Id == Id);

            if (binInCurrentPage != null)
            {
                expandedRowId = Id;
                StateHasChanged();
            }
            else
            {
                var bin = wasteBins?.FirstOrDefault(b => b.Id == Id);
                if (bin != null)
                {
                    searchText = "";
                    statusFilter = "";
                    fillLevelFilter = "";
                    ApplyFilters();

                    int binIndex = filteredBins.IndexOf(bin);
                    if (binIndex >= 0)
                    {
                        currentPage = (binIndex / pageSize) + 1;
                        await Task.Delay(100);
                        expandedRowId = Id;
                        StateHasChanged();
                    }
                }
            }
        }
    }
}